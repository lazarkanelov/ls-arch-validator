{
  "probe_type": "api_parity",
  "probe_name": "RDS API Parity Probe",
  "probed_features": [
    "connection_pooling",
    "parameter_groups",
    "prepared_statements",
    "ssl_connections",
    "transaction_isolation"
  ],
  "source_files": {
    "src/probes/rds_parity_probe.py": "\"\"\"RDS MySQL API Parity Probe for LocalStack.\"\"\"\nfrom __future__ import annotations\n\nimport mysql.connector\nfrom dataclasses import dataclass\nfrom typing import Optional\nfrom src.config import settings\n\n\n@dataclass\nclass ProbeResult:\n    feature: str\n    expected: str\n    actual: str\n    passed: bool\n    error: Optional[str] = None\n\n\nclass RDSParityProbe:\n    \"\"\"Tests RDS MySQL API parity with AWS.\"\"\"\n    \n    def __init__(self):\n        self.results = []\n    \n    def test_connection_pooling(self) -> ProbeResult:\n        \"\"\"Test connection pool behavior matches AWS RDS.\"\"\"\n        try:\n            pool = mysql.connector.pooling.MySQLConnectionPool(\n                pool_name=\"test_pool\",\n                pool_size=5,\n                host=settings.db_host,\n                user=settings.db_username,\n                password=settings.db_password,\n                database=settings.db_name,\n            )\n            \n            # Get and return connections\n            conns = [pool.get_connection() for _ in range(5)]\n            for c in conns:\n                c.close()\n            \n            return ProbeResult(\n                feature=\"connection_pooling\",\n                expected=\"Pool of 5 connections\",\n                actual=\"Pool created successfully\",\n                passed=True,\n            )\n        except Exception as e:\n            return ProbeResult(\n                feature=\"connection_pooling\",\n                expected=\"Pool of 5 connections\",\n                actual=str(e),\n                passed=False,\n                error=str(e),\n            )\n    \n    def test_prepared_statements(self) -> ProbeResult:\n        \"\"\"Test prepared statement execution.\"\"\"\n        try:\n            conn = mysql.connector.connect(\n                host=settings.db_host,\n                user=settings.db_username,\n                password=settings.db_password,\n                database=settings.db_name,\n            )\n            cursor = conn.cursor(prepared=True)\n            cursor.execute(\"SELECT ? + ?\", (1, 2))\n            result = cursor.fetchone()[0]\n            conn.close()\n            \n            return ProbeResult(\n                feature=\"prepared_statements\",\n                expected=\"3\",\n                actual=str(result),\n                passed=result == 3,\n            )\n        except Exception as e:\n            return ProbeResult(\n                feature=\"prepared_statements\",\n                expected=\"3\",\n                actual=str(e),\n                passed=False,\n                error=str(e),\n            )\n    \n    def test_transaction_isolation(self) -> ProbeResult:\n        \"\"\"Test transaction isolation levels.\"\"\"\n        try:\n            conn = mysql.connector.connect(\n                host=settings.db_host,\n                user=settings.db_username,\n                password=settings.db_password,\n            )\n            cursor = conn.cursor()\n            cursor.execute(\"SET TRANSACTION ISOLATION LEVEL REPEATABLE READ\")\n            cursor.execute(\"SELECT @@transaction_isolation\")\n            level = cursor.fetchone()[0]\n            conn.close()\n            \n            return ProbeResult(\n                feature=\"transaction_isolation\",\n                expected=\"REPEATABLE-READ\",\n                actual=level,\n                passed=\"REPEATABLE\" in level.upper(),\n            )\n        except Exception as e:\n            return ProbeResult(\n                feature=\"transaction_isolation\",\n                expected=\"REPEATABLE-READ\",\n                actual=str(e),\n                passed=False,\n                error=str(e),\n            )\n    \n    def run_all_probes(self) -> list[ProbeResult]:\n        \"\"\"Run all RDS parity probes.\"\"\"\n        self.results = [\n            self.test_connection_pooling(),\n            self.test_prepared_statements(),\n            self.test_transaction_isolation(),\n        ]\n        return self.results\n"
  },
  "test_files": {
    "tests/test_rds_parity.py": "\"\"\"Tests for RDS MySQL API parity.\"\"\"\nimport pytest\nfrom src.probes.rds_parity_probe import RDSParityProbe\n\n\nclass TestRDSParity:\n    @pytest.fixture\n    def probe(self):\n        return RDSParityProbe()\n    \n    def test_connection_pooling(self, probe):\n        result = probe.test_connection_pooling()\n        assert result.passed, f\"Connection pooling failed: {result.error}\"\n    \n    def test_prepared_statements(self, probe):\n        result = probe.test_prepared_statements()\n        assert result.passed, f\"Prepared statements failed: {result.error}\"\n    \n    def test_transaction_isolation(self, probe):\n        result = probe.test_transaction_isolation()\n        assert result.passed, f\"Transaction isolation failed: {result.error}\"\n"
  },
  "requirements": [
    "mysql-connector-python>=8.0.0",
    "pytest>=7.0.0"
  ]
}