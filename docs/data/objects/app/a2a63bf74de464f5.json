{
  "probe_type": "integration",
  "probe_name": "Lambda-DynamoDB Integration Probe",
  "probed_features": [
    "api_gateway_lambda_proxy",
    "dead_letter_queue",
    "event_source_mapping",
    "lambda_dynamodb_streams"
  ],
  "source_files": {
    "src/probes/integration_probe.py": "\"\"\"Integration Probe for Lambda-DynamoDB-API Gateway.\"\"\"\nfrom __future__ import annotations\n\nimport boto3\nimport json\nimport time\nfrom dataclasses import dataclass\nfrom typing import Optional\nimport os\n\n\n@dataclass\nclass ProbeResult:\n    feature: str\n    expected: str\n    actual: str\n    passed: bool\n    error: Optional[str] = None\n\n\nclass IntegrationProbe:\n    \"\"\"Tests cross-service integrations.\"\"\"\n    \n    def __init__(self):\n        endpoint = os.getenv('AWS_ENDPOINT_URL', 'http://localhost:4566')\n        self.lambda_client = boto3.client('lambda', endpoint_url=endpoint, region_name='us-east-1')\n        self.dynamodb = boto3.client('dynamodb', endpoint_url=endpoint, region_name='us-east-1')\n        self.api_gw = boto3.client('apigateway', endpoint_url=endpoint, region_name='us-east-1')\n    \n    def test_lambda_dynamodb_stream(self) -> ProbeResult:\n        \"\"\"Test Lambda trigger from DynamoDB Streams.\"\"\"\n        try:\n            # Check if event source mapping exists\n            mappings = self.lambda_client.list_event_source_mappings(\n                FunctionName='order-processor'\n            )\n            stream_mappings = [m for m in mappings.get('EventSourceMappings', []) if 'dynamodb' in m.get('EventSourceArn', '').lower()]\n            return ProbeResult(\n                feature='lambda_dynamodb_streams',\n                expected='Event source mapping configured',\n                actual=f'{len(stream_mappings)} DynamoDB stream mappings found',\n                passed=len(stream_mappings) > 0,\n            )\n        except Exception as e:\n            return ProbeResult(\n                feature='lambda_dynamodb_streams',\n                expected='Stream trigger configured',\n                actual=str(e),\n                passed=False,\n                error=str(e),\n            )\n    \n    def test_api_gateway_lambda_proxy(self) -> ProbeResult:\n        \"\"\"Test API Gateway Lambda proxy integration.\"\"\"\n        try:\n            apis = self.api_gw.get_rest_apis()\n            order_api = next((a for a in apis.get('items', []) if 'order' in a.get('name', '').lower()), None)\n            if not order_api:\n                return ProbeResult(\n                    feature='api_gateway_lambda_proxy',\n                    expected='Order API found',\n                    actual='No order API found',\n                    passed=False,\n                )\n            resources = self.api_gw.get_resources(restApiId=order_api['id'])\n            return ProbeResult(\n                feature='api_gateway_lambda_proxy',\n                expected='API Gateway with Lambda proxy',\n                actual=f'API {order_api[\"name\"]} with {len(resources.get(\"items\", []))} resources',\n                passed=True,\n            )\n        except Exception as e:\n            return ProbeResult(\n                feature='api_gateway_lambda_proxy',\n                expected='API Gateway configured',\n                actual=str(e),\n                passed=False,\n                error=str(e),\n            )\n    \n    def test_lambda_invocation_chain(self) -> ProbeResult:\n        \"\"\"Test synchronous Lambda invocation.\"\"\"\n        try:\n            response = self.lambda_client.invoke(\n                FunctionName='order-api-handler',\n                InvocationType='RequestResponse',\n                Payload=json.dumps({'path': '/health', 'httpMethod': 'GET', 'headers': {}}),\n            )\n            payload = json.loads(response['Payload'].read())\n            return ProbeResult(\n                feature='lambda_invocation',\n                expected='Lambda returns 200',\n                actual=f'Status: {payload.get(\"statusCode\", \"unknown\")}',\n                passed=response['StatusCode'] == 200,\n            )\n        except Exception as e:\n            return ProbeResult(\n                feature='lambda_invocation',\n                expected='Lambda invocation succeeds',\n                actual=str(e),\n                passed=False,\n                error=str(e),\n            )\n    \n    def run_all_probes(self) -> list[ProbeResult]:\n        return [\n            self.test_lambda_dynamodb_stream(),\n            self.test_api_gateway_lambda_proxy(),\n            self.test_lambda_invocation_chain(),\n        ]\n"
  },
  "test_files": {
    "tests/test_integration.py": "\"\"\"Tests for Lambda-DynamoDB-API Gateway integration.\"\"\"\nimport pytest\nfrom src.probes.integration_probe import IntegrationProbe\n\n\nclass TestIntegration:\n    @pytest.fixture\n    def probe(self):\n        return IntegrationProbe()\n    \n    def test_lambda_dynamodb_stream(self, probe):\n        result = probe.test_lambda_dynamodb_stream()\n        assert result.passed, f\"DynamoDB Streams integration failed: {result.error}\"\n    \n    def test_api_gateway_lambda_proxy(self, probe):\n        result = probe.test_api_gateway_lambda_proxy()\n        assert result.passed, f\"API Gateway integration failed: {result.error}\"\n    \n    def test_lambda_invocation_chain(self, probe):\n        result = probe.test_lambda_invocation_chain()\n        assert result.passed, f\"Lambda invocation failed: {result.error}\"\n"
  },
  "requirements": [
    "boto3>=1.28.0",
    "pytest>=7.0.0"
  ]
}