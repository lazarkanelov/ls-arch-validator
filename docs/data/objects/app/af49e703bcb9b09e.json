{
  "probe_type": "api_parity",
  "probe_name": "DynamoDB API Parity Probe",
  "probed_features": [
    "batch_write_item",
    "conditional_expressions",
    "gsi_consistency",
    "query_pagination",
    "transact_write_items"
  ],
  "source_files": {
    "src/probes/dynamodb_parity.py": "\"\"\"DynamoDB API Parity Probe for LocalStack.\"\"\"\nfrom __future__ import annotations\n\nimport boto3\nfrom dataclasses import dataclass\nfrom typing import Optional\nimport os\n\n\n@dataclass\nclass ProbeResult:\n    feature: str\n    expected: str\n    actual: str\n    passed: bool\n    error: Optional[str] = None\n\n\nclass DynamoDBParityProbe:\n    \"\"\"Tests DynamoDB API parity with AWS.\"\"\"\n    \n    def __init__(self):\n        self.client = boto3.client(\n            'dynamodb',\n            endpoint_url=os.getenv('AWS_ENDPOINT_URL', 'http://localhost:4566'),\n            region_name='us-east-1',\n        )\n        self.table_name = 'test-orders'\n    \n    def test_batch_write_item(self) -> ProbeResult:\n        \"\"\"Test BatchWriteItem with 25 items (AWS limit).\"\"\"\n        try:\n            items = [\n                {'PutRequest': {'Item': {'order_id': {'S': f'order-{i}'}, 'customer_id': {'S': 'cust-1'}}}}\n                for i in range(25)\n            ]\n            response = self.client.batch_write_item(\n                RequestItems={self.table_name: items}\n            )\n            unprocessed = response.get('UnprocessedItems', {})\n            return ProbeResult(\n                feature='batch_write_item',\n                expected='25 items written, 0 unprocessed',\n                actual=f'{25 - len(unprocessed.get(self.table_name, []))} written',\n                passed=len(unprocessed) == 0,\n            )\n        except Exception as e:\n            return ProbeResult(\n                feature='batch_write_item',\n                expected='25 items written',\n                actual=str(e),\n                passed=False,\n                error=str(e),\n            )\n    \n    def test_transact_write_items(self) -> ProbeResult:\n        \"\"\"Test TransactWriteItems with conditional checks.\"\"\"\n        try:\n            self.client.transact_write_items(\n                TransactItems=[\n                    {'Put': {'TableName': self.table_name, 'Item': {'order_id': {'S': 'tx-1'}, 'customer_id': {'S': 'cust-tx'}}}},\n                    {'Put': {'TableName': self.table_name, 'Item': {'order_id': {'S': 'tx-2'}, 'customer_id': {'S': 'cust-tx'}}, 'ConditionExpression': 'attribute_not_exists(order_id)'}},\n                ]\n            )\n            return ProbeResult(\n                feature='transact_write_items',\n                expected='Transaction committed',\n                actual='Transaction committed',\n                passed=True,\n            )\n        except Exception as e:\n            return ProbeResult(\n                feature='transact_write_items',\n                expected='Transaction committed',\n                actual=str(e),\n                passed=False,\n                error=str(e),\n            )\n    \n    def test_query_pagination(self) -> ProbeResult:\n        \"\"\"Test Query with pagination using LastEvaluatedKey.\"\"\"\n        try:\n            all_items = []\n            last_key = None\n            while True:\n                kwargs = {\n                    'TableName': self.table_name,\n                    'KeyConditionExpression': 'customer_id = :cid',\n                    'ExpressionAttributeValues': {':cid': {'S': 'cust-1'}},\n                    'Limit': 5,\n                }\n                if last_key:\n                    kwargs['ExclusiveStartKey'] = last_key\n                response = self.client.query(**kwargs)\n                all_items.extend(response.get('Items', []))\n                last_key = response.get('LastEvaluatedKey')\n                if not last_key:\n                    break\n            return ProbeResult(\n                feature='query_pagination',\n                expected='Paginated results retrieved',\n                actual=f'Retrieved {len(all_items)} items across pages',\n                passed=True,\n            )\n        except Exception as e:\n            return ProbeResult(\n                feature='query_pagination',\n                expected='Paginated results',\n                actual=str(e),\n                passed=False,\n                error=str(e),\n            )\n    \n    def run_all_probes(self) -> list[ProbeResult]:\n        return [\n            self.test_batch_write_item(),\n            self.test_transact_write_items(),\n            self.test_query_pagination(),\n        ]\n"
  },
  "test_files": {
    "tests/test_dynamodb_parity.py": "\"\"\"Tests for DynamoDB API parity.\"\"\"\nimport pytest\nfrom src.probes.dynamodb_parity import DynamoDBParityProbe\n\n\nclass TestDynamoDBParity:\n    @pytest.fixture\n    def probe(self):\n        return DynamoDBParityProbe()\n    \n    def test_batch_write_item(self, probe):\n        result = probe.test_batch_write_item()\n        assert result.passed, f\"BatchWriteItem failed: {result.error}\"\n    \n    def test_transact_write_items(self, probe):\n        result = probe.test_transact_write_items()\n        assert result.passed, f\"TransactWriteItems failed: {result.error}\"\n    \n    def test_query_pagination(self, probe):\n        result = probe.test_query_pagination()\n        assert result.passed, f\"Query pagination failed: {result.error}\"\n"
  },
  "requirements": [
    "boto3>=1.28.0",
    "pytest>=7.0.0"
  ]
}